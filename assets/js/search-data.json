{
  
    
        "post0": {
            "title": "Introduction",
            "content": "Brute Force . Idea: Generate all possible subarrays from the original array and find the one that has the greatest sum. . Time Complexity: $O(n^2)$ . The two nested for loops call line 6 of the algorithm $n (n+1)/2$ times, meaning we have a runtime of $O(n^2)$. . Space Complexity: $O(1)$ . Trivial. . &quot;The Maximum Sum Subarray Problem&quot; . &quot;Five different algorithms to solve the maximum sum subarray problem.&quot; . toc:true- branch: master | badges: true | comments: true | categories: [jupyter, algorithms, dynamic-programming, sliding-window, array] | image: images/some_folder/your_image.png | hide: false | search_exclude: true | metadata_key1: metadata_value1 | metadata_key2: metadata_value2 | . def max_subarray_brute_force(nums): &quot;&quot;&quot;compute the maximum subarray with a brute force technique&quot;&quot;&quot; max_sum = -float(&#39;inf&#39;) for i in range(len(nums)): for j in range(i, len(nums)): max_sum = max(max_sum, sum(nums[i:j+1])) return max_sum . Divide And Conquer . Idea: Let the contiguous array that results in the maximum sum be dennoted by nums[i, ..., j]. Then if we are looking at the array nums[low, ..., high], we know that the maximum subarray nums[i, ..., j] must be located in exactly one of three cases: . entirely in the subarray nums[low, ..., mid] so that $low leq i leq j leq mid$ | entirely in the subarray nums[mid+1, ..., high] so that $mid+1 leq i leq j leq high$ | crossing the midpoint so that $low leq i leq mid &lt; j leq high$ | where mid = (l + r) // 2. . We can find the maximum subarrays of nums[low, ..., mid] and nums[mid+1, ..., high] recursively because these two problems are smaller instances of the original problem of finding a maximum subarray. However, the problem of finding a maximum subarray that crosses the midpoint is not a smaller instance of our orignal problem because it has the added constraint that the subarray it chooses must cross the midpoint. . So the function max_crossing_subarray() will compute the maximum subarray that crosses the midpoint. It works by computing the left sum, the biggest possible sum we can get by starting at mid and repeatedly adding the number to the left of mid. Similarly, we compute the right sum, the biggest possible sum we can get by starting at mid and repeatedly adding the number to the right of mid. Then we add the left sum and right sum because together they are the greatest sums formed that must go through mid. This function returns the indices demarcating a maximum subarray that crosses the midpoint along with the sum of the values in this maximum subarray. . Lastly, max_subarray_helper() is a helper function that does most of the work organizing the three cases described above. It also returns the indices demarcating a maximum subarray that crosses the midpoint along with the sum of the values in this maximum subarray. . Formally, we can express this as a recurrence relation: . begin{align*} dp[i][j] &amp;= begin{cases} 0 &amp; text{if } i == j max(dp[i][mid], dp[mid+1][j], text{max_crossing_subarray}(i, mid, j, nums)) &amp; text{else} end{cases} end{align*}where . $mid = i + (j - i) // 2$ | $dp[i][j]$ is the maximum sum found in the subarray in nums[i, ..., j] (inclusive of $i,j$). | To compute the maximum subarray sum, simply compute $dp[0][len(nums)-1]$. . Time Complexity: $O(n log n)$ . Let $T(n)$ be the runtime of max_subarray_helper() on an array of length $n$. max_subarray_helper() has the recurrence relation $T(n) = 2T(n/2) + Theta(n)$. The term $2T(n/2)$ comes from the two recursive calls that are each made on half the input, ie. on nums[low, ..., mid] and nums[mid+1, ..., high]. The term $ Theta(n)$ comes from calling max_crossing_subarray() which runs in linear time. Using the master method (outside the scope of this article), we find that $T(n) = O(n log n)$. . Space Complexity: $O(1)$ . Trivial. Note: this space complexity does not take into account the space used by the recursive stack. . def max_crossing_subarray(low, mid, high, nums): &quot;&quot;&quot;compute the maximum subarray that crosses the midpoint.&quot;&quot;&quot; # get largest left sum that ends at m, ie get largest sum of the form nums[i:mid+1] for some i left_sum = -float(&#39;inf&#39;) sum_ = 0 for i in range(mid, low - 1, -1): sum_ += nums[i] if sum_ &gt; left_sum: left_sum = sum_ max_left = i # get largest right sum that starts at m, ie get largest sum of the form nums[mid+1:j] for some j right_sum = -float(&#39;inf&#39;) sum_ = 0 for j in range(mid+1, high+1): sum_ += nums[j] if sum_ &gt; right_sum: right_sum = sum_ max_right = j return (max_left, max_right, left_sum + right_sum) . def max_subarray_helper(low, high, nums): &quot;&quot;&quot; find the maximum subarray in nums[low, ..., high] by recursively computing the maximum subarray to the left of the midpoint, to the right of the midpoint, and crossing the midpoint&quot;&quot;&quot; if low == high: # base case return (low, high, nums[low]) # compute the maximum subarray to left of mid, to the right of mid, and crossing mid mid = low + (high - low) // 2 left_low, left_high, left_sum = max_subarray_helper(low, mid, nums) right_low, right_high, right_sum = max_subarray_helper(mid + 1, high, nums) cross_low, cross_high, cross_sum = max_crossing_subarray(low, mid, high, nums) if left_sum &gt;= right_sum and left_sum &gt;= cross_sum: # if left_sum is the biggest return left_low, left_high, left_sum if right_sum &gt;= left_sum and right_sum &gt;= cross_sum: # if right_sum is the biggest return right_low, right_high, right_sum return cross_low, cross_high, cross_sum . def max_subarray_div_and_conq(nums): &quot;&quot;&quot;compute the maximum subarray with a divide and conquer technique&quot;&quot;&quot; low, high = 0, len(nums) - 1 _, _, max_sum = max_subarray_helper(low, high, nums) return max_sum . Dynamic Programming . Idea: If we already know the largest sum in nums[0:i], then the largest sum in nums[0:i+1] is nums[0:i] + nums[i] if nums[0:i] is positive. If nums[0:i] is negative, adding it to nums[i] would just make it smaller, so the largest sum in nums[0:i+1] is just nums[i]. This idea naturally lends itself to dynamic programming. In particular, this problem has the recurrence: . begin{align*} dp[i] &amp;= begin{cases} 0 &amp; text{if } i &lt; 0 nums[i] + dp[i-1] &amp; dp[i-1] &gt; 0 nums[i] &amp; text{else} end{cases} end{align*}where $dp[i]$ is the maximum sum obtained from contigious subarrays in the first $i$ elements of nums. This recurrence relation can be written more succinctly as begin{align*} dp[i] &amp;= begin{cases} 0 &amp; text{if } i &lt; 0 nums[i] + max(dp[i-1], 0) &amp; text{else} end{cases} end{align*} . We will implement a bottom-up solution to this dynamic programming problem, meaning we compute the maximum sum in the first element of nums, the first two elements of nums, the first three elements of nums, etc. At each iteration, we compute the maximum sum seen so far. . To compute the maximum subarray sum, simply compute $dp[len(nums)-1]$. . Time Complexity: $O(n)$ . It takes constant time to compute a single entry in the table $dp$. And because there are $n$ entries in the table, it will take $O(n)$ time to fill in the entire table. . Space Complexity: $O(n)$ . The table has $n$ entries so this algorithim take $O(n)$ space. . def max_subarray_dp(nums): &quot;&quot;&quot;compute the maximum subarray with a dynamic programming technique&quot;&quot;&quot; dp = [0] * (len(nums)) dp[0] = max_sum = nums[0] for i in range(1, len(nums)): dp[i] = nums[i] + max(dp[i-1], 0) max_sum = max(max_sum, dp[i]) return max_sum . Kadane&#39;s Algorithm . Idea: Kadane&#39;s algorithm is the exact same as the dynamic programming solution but it uses $O(1)$ space instead of $O(n)$ space. Recall the recurrence relation for this problem is begin{align*} dp[i] &amp;= begin{cases} 0 &amp; text{if } i &lt; 0 nums[i] + max(dp[i-1], 0) &amp; text{else} end{cases} end{align*} A closer analysis reveals that to compute $dp[i]$, we only need $dp[i-1]$. We don&#39;t need any of the other previous entries of $dp$. This means we do not to store the entire $dp$ table (which takes $O(n)$ space) and instead can store just $dp[i-1]$ as current_sum. This is Kadane&#39;s algorithm. . Again, to compute the maximum subarray sum, simply compute $dp[len(nums)-1]$. . Time Complexity: $O(n)$ . We must compute $n$ different values of $dp$. . Space Complexity: $O(1)$ . We only store only the previous sum to compute the current sum. . def max_subarray_kadane(nums): &quot;&quot;&quot;compute the maximum subarray with the Kadane&#39;s algorithm technique&quot;&quot;&quot; max_sum = current_sum = nums[0] for i in range(1, len(nums)): current_sum = nums[i] + max(current_sum, 0) max_sum = max(max_sum, current_sum) return max_sum . Sliding Window . Idea: Use two pointers low and high to maintain a sliding window across the array. At every iteration, move high one to right and add the new element to the running sum sum_. If the sum is less than the new element nums[high], then we would get a higher sum just by starting our sum from nums[high]. So we want to keep on moving the left pointer until sum_ &lt; nums[high] is no longer true; this is expressed with a while loop. (A closer look reveals that if we ever have sum_ &lt; nums[high] and wish to start our sum from nums[high], we can immediately move the left pointer to nums[high] if sum_ &lt; nums[high], no need for a while loop; this optimized version is commented out. Also, at every iteration we record the maximum sum so once we&#39;re done iterating through the array, we can just return the maximum sum. . Time Complexity: $O(n)$ . We iterate through the entire array once by moving two pointers. . Space Complexity: $O(1)$ . Trivial. . def max_subarray_sliding_window(nums): &quot;&quot;&quot;compute the maximum subarray with a sliding window technique&quot;&quot;&quot; low, sum_ = 0, 0 max_sum = -float(&#39;inf&#39;) for high in range(len(nums)): sum_ += nums[high] while sum_ &lt; nums[high]: sum_ -= nums[low] low += 1 # optimized version # if sum_ &lt; nums[high]: # sum_ = nums[high] # low = high max_sum = max(max_sum, sum_) return max_sum . Comparison . Time &amp; Space Complexity: We can easily analyse the space and runtime complexity of each algorithm. . Technique Runtime &nbsp; Space . Brute Force | $O(n^2)$ | $O(1)$ | . Divide &amp; Conquer | $O(n logn)$ | $O(1)$ | . Sliding Window | $O(n)$ | $O(1)$ | . Dynamic Programming | $O(n)$ | $O(n)$ | . Kadane&#39;s Algorithm | $O(n)$ | $O(1)$ | . Sliding Window &amp; Kadane&#39;s Algorithm: If you take a closer look, you can see that Sliding Window and Kadane&#39;s Algorithm are essentially the same exact algorithm but implemented differently. . Recurrence Relations: Note that DP/Kadane&#39;s algorithm can be expressed by the recurrence relation begin{align*} dp[i] &amp;= begin{cases} 0 &amp; text{if } i &lt; 0 nums[i] + max(dp[i-1], 0) &amp; text{else} end{cases} end{align*} but the divide and conquer technique can be expressed by the recurrence relation begin{align*} dp[i][j] &amp;= begin{cases} 0 &amp; text{if } i == j max(dp[i][mid], dp[mid+1][j], text{max_crossing_subarray}(i, mid, j, nums)) &amp; text{else} end{cases} end{align*} . Both recurrences display optimal substructure, meaning the solution to the original problem can be achieved by finding the optimal solution to smaller subproblems. Yet there are differences. The first recurrence is 1D while the second recurrence is 2D. This explains why the first recurrence results in an $O(n)$ algorithm and the second recurrence results in an $O(n log n )$ algorithm. . Timing Maximum Subarray Algorithms . The table above states the worst case runtime of various maximum subarray algorithms. However, how many seconds does it actually take to compute the maximum subarray sum for each algorithm? How much faster is one algorithm than another? . Below I run the five different maximum subarray algorithms and time their runtime on inputs of different sizes. Every element of the input array is randomly (uniformly) choosen from the interval $[-100, 100]$. Scroll past the code to see the results. . Note that, as expected, the $O(n^2)$ brute force algorithm is the slowest, the $O(n log n)$ divide and conquer algorithm is the second slowest, and the $O(n)$ sliding window algorithm, (non-constant space) dynamic programming algorithm, and Kadane&#39;s algorithm are the fastest. This emperically confirms what we showed via theory. . Works Cited . Cormen, Thomas H, et al. Introduction to Algorithms. 3rd ed., Cambridge (Massachusetts) ; London, MIT Press, 2007, pp. 68–74. | Fabré, Maarten. “Plot Timings for a Range of Inputs.” Code Review Stack Exchange, 9 June 2017, codereview.stackexchange.com/a/165362/260966. Accessed 25 July 2022. | Leetcode. “Maximum Subarray.” Leetcode.com, leetcode.com/problems/maximum-subarray/discuss/. Accessed 25 July 2022. |",
            "url": "https://ez2rok.github.io/algorithmic-mutterings/2022/08/07/maximum-subarray-sum.html",
            "relUrl": "/2022/08/07/maximum-subarray-sum.html",
            "date": " • Aug 7, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://ez2rok.github.io/algorithmic-mutterings/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://ez2rok.github.io/algorithmic-mutterings/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://ez2rok.github.io/algorithmic-mutterings/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://ez2rok.github.io/algorithmic-mutterings/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}